(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[931],{9306:function(n,e,o){Promise.resolve().then(o.bind(o,503))},503:function(n,e,o){"use strict";o.r(e),o.d(e,{default:function(){return h}});var i=o(7437);o(5161);var t=o(9016),r=o(5669),s=o(2265),a=o(7776);function c(n){let e=(0,s.useRef)(null),o=(0,s.useMemo)(()=>({u_intensity:{value:.3},u_raise:{value:0},u_colorBase:{value:new a.Color("#000000")},u_colorBeach:{value:new a.Color("#000000")},u_colorMid:{value:new a.Color("#000000")},u_colorPeak:{value:new a.Color("#000000")}}),[]),[t,c]=(0,s.useState)(!1);return o.u_colorBase.value=n.colorBase,o.u_colorBeach.value=n.colorBeach,o.u_colorMid.value=n.colorMid,o.u_colorPeak.value=n.colorPeak,(0,r.x)((i,r)=>{let s=e.current;if(!s)return;let{clock:c}=i;s.rotation.y+=.1*n.spinSpeed*r,o.u_intensity.value=a.MathUtils.lerp(o.u_intensity.value,t?1:.3,.02),o.u_raise.value=a.MathUtils.lerp(o.u_raise.value,t?1:0,.02)}),(0,s.useEffect)(()=>{if(t){var o;let i=new a.Vector3;null===(o=e.current)||void 0===o||o.getWorldPosition(i),n.setTooltipPos({x:i.x,y:i.y,z:i.z})}},[t,n]),(0,i.jsxs)("mesh",{ref:e,...n,onClick:e=>window.location.href=n.href,onPointerOver:()=>{c(!0),document.body.style.cursor="pointer",n.tooltip&&n.setTooltipName(n.tooltip)},onPointerOut:()=>{c(!1),document.body.style.cursor="auto",n.setTooltipName("")},children:[(0,i.jsx)("icosahedronGeometry",{args:[2,30]}),(0,i.jsx)("shaderMaterial",{uniforms:o,fragmentShader:"\n//varying vec3 Normal;\n//varying vec3 Position;\n//varying vec2 vUv;\nvarying float vDisplacement;\n\n//uniform float u_time;\nuniform vec3 u_colorPeak;\nuniform vec3 u_colorMid;\nuniform vec3 u_colorBeach;\nuniform vec3 u_colorBase;\n\nvoid main() {\n  vec3 color = u_colorBase;\n\n  if (vDisplacement > 0.25f) {\n    color = u_colorPeak;\n  }\n  else if (vDisplacement > 0.1f) {\n    color = u_colorMid;\n  }\n  else if (vDisplacement > 0.01f) {\n    color = u_colorBeach;\n  }\n\n  gl_FragColor = vec4(color,1.0);\n}\n",vertexShader:"\n//varying vec3 Normal;\n//varying vec3 Position;\n//varying vec2 vUv;\nvarying float vDisplacement;\n\n//uniform float u_time;\nuniform float u_intensity;\nuniform float u_raise;\n\n// Classic Perlin 3D Noise \n// by Stefan Gustavson\n//\nvec4 permute(vec4 x) {\n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec3 P) {\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod(Pi0, 289.0);\n    Pi1 = mod(Pi1, 289.0);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 / 7.0;\n    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 / 7.0;\n    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return 2.2 * n_xyz;\n}\n\nfloat layeredPerlin(vec3 P) {\n  float sum = 0.0f;\n\n  sum += 0.5f * cnoise(P);\n  sum += 0.25f * cnoise(2.0f * P);\n  sum += 0.125f * cnoise(4.0f * P);\n  sum += 0.075f * cnoise(8.0f * P);\n  //add more\n\n  return sum;\n}\n\n// End of Perlin Noise Code\n\nvoid main() {\n  //Normal = normalize(normalMatrix * normal);\n  //Position = position;\n  //vUv = uv;\n\n  //Perlin Displacement\n  vDisplacement = layeredPerlin(position);\n  vec3 newPosition = position + normal * (u_intensity * vDisplacement + u_raise);\n\n  vec4 modelPosition = modelMatrix * vec4(newPosition, 1.0);\n\n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectedPosition = projectionMatrix * viewPosition;\n\n  gl_Position = projectedPosition;\n}\n"}),n.children]})}function l(n){let e=(0,s.useRef)(null),o=(0,s.useMemo)(()=>({u_time:{value:0},u_intensity:{value:.05},u_raise:{value:0},randomFactors:{value:new a.Vector3(1,1,1)},u_colorBase:{value:new a.Color("#000000")},u_colorBeach:{value:new a.Color("#000000")},u_colorMid:{value:new a.Color("#000000")},u_colorPeak:{value:new a.Color("#000000")}}),[]),[t,c]=(0,s.useState)(!1);return o.u_colorBase.value=n.colorBase,o.u_colorBeach.value=n.colorBeach,o.u_colorMid.value=n.colorMid,o.u_colorPeak.value=n.colorPeak,(0,r.x)((i,r)=>{let s=e.current;if(!s)return;let{clock:c}=i;o.u_time.value=.2*c.getElapsedTime(),s.rotation.y+=.1*n.spinSpeed*r,o.u_raise.value=a.MathUtils.lerp(o.u_raise.value,t?1:0,.02)}),(0,s.useEffect)(()=>{if(t){var o;let i=new a.Vector3;null===(o=e.current)||void 0===o||o.getWorldPosition(i),n.setTooltipPos({x:i.x,y:i.y,z:i.z})}},[t,n]),(0,i.jsxs)("mesh",{ref:e,...n,onClick:e=>window.location.href=n.href,onPointerOver:()=>{c(!0),document.body.style.cursor="pointer",n.tooltip&&n.setTooltipName(n.tooltip)},onPointerOut:()=>{c(!1),document.body.style.cursor="auto",n.setTooltipName("")},children:[(0,i.jsx)("icosahedronGeometry",{args:[2,30]}),(0,i.jsx)("shaderMaterial",{uniforms:o,fragmentShader:"\n//varying vec3 Normal;\n//varying vec3 Position;\n//varying vec2 vUv;\nvarying float vDisplacement;\n\n//uniform float u_time;\nuniform vec3 u_colorPeak;\nuniform vec3 u_colorMid;\nuniform vec3 u_colorBeach;\nuniform vec3 u_colorBase;\n\nvoid main() {\n  vec3 color = u_colorBase;\n\n  if (vDisplacement > 0.2f) {\n    color = u_colorPeak;\n  }\n  else if (vDisplacement > 0.05f) {\n    color = u_colorMid;\n  }\n  else if (vDisplacement > 0.0001f) {\n    color = u_colorBeach;\n  }\n\n  gl_FragColor = vec4(color,1.0);\n}\n",vertexShader:"\n//varying vec3 Normal;\n//varying vec3 Position;\n//varying vec2 vUv;\nvarying float vDisplacement;\n\nuniform float u_time;\nuniform float u_intensity;\nuniform float u_raise;\nuniform vec3 randomFactors;\n\n// Classic Perlin 3D Noise \n// by Stefan Gustavson\n//\nvec4 permute(vec4 x) {\n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat cnoise(vec3 P) {\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod(Pi0, 289.0);\n    Pi1 = mod(Pi1, 289.0);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 / 7.0;\n    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 / 7.0;\n    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return 2.2 * n_xyz;\n}\n\nfloat layeredPerlin(vec3 P) {\n  float sum = 0.0f;\n\n  sum += 0.5f * cnoise(P + 0.2 * u_time);\n  sum += 0.25f * cnoise(4.0f * sum * P);\n  sum += 0.125f * cnoise(16.0f * sum * P);\n  sum += 0.075f * cnoise(64.0f * sum * P);\n  //add more\n\n  return sum;\n}\n\n// End of Perlin Noise Code\n\nvoid main() {\n  //Normal = normalize(normalMatrix * normal);\n  //Position = position;\n  //vUv = uv;\n\n  //Perlin Displacement\n  vDisplacement = layeredPerlin(position);\n  //vec3 newPosition = position + normal * (u_intensity * vDisplacement + u_raise);\n  vec3 newPosition = position + normal * (u_raise);\n\n  vec4 modelPosition = modelMatrix * vec4(newPosition, 1.0);\n\n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectedPosition = projectionMatrix * viewPosition;\n\n  gl_Position = projectedPosition;\n}\n"}),n.children]})}var u=o(7871);function v(n){let e=(0,s.useRef)(null),o=(0,r.w)(n=>n.camera),[t]=(0,u.m)(["Textures/noiseTexture.png"]),c=(0,s.useMemo)(()=>({u_time:{value:0},u_resolution:{value:new a.Vector2(0,0)},u_camPos:{value:new a.Vector3(0,5,5)},u_camRot:{value:new a.Matrix4},u_noiseTex:{type:"t",value:t}}),[t]);return(0,r.x)(n=>{if(!e.current)return;let{clock:i}=n;c.u_time.value=i.getElapsedTime(),c.u_resolution.value=new a.Vector2(1*window.innerWidth,1*window.innerHeight),c.u_camPos.value=o.position,c.u_camRot.value=o.matrixWorldInverse}),(0,i.jsxs)("mesh",{ref:e,...n,children:[(0,i.jsx)("icosahedronGeometry",{args:[3,30]}),(0,i.jsx)("shaderMaterial",{uniforms:c,fragmentShader:"\n//varying vec3 Normal;\n//varying vec3 Position;\nvarying vec2 vUv;\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec3 u_camPos;\nuniform mat4 u_camRot;\nuniform sampler2D u_noiseTex;\n\nconst float _voidCutoff = 0.04;\nconst float _sphereRadius = 0.2;\nconst float _innerDiscRadius = 0.201;\nconst float _outerDiscRadius = 1.0;\nconst float _lightBending = 0.05;\n\nconst float _dopplerEffect = 66.0;\nconst float _hueShift = -0.03;\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.0001\n\n//distance function for a sphere at world center\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat sdInfCylinder(vec3 p, float radius) {\n    return length(vec2(p.x, p.z)) - radius;\n}\n\n// vertical cylinder\nfloat sdCylinder(vec3 p, float height, float radius) {\n    vec2 dist = abs(vec2(length(p.xz), p.y)) - vec2(radius, height);\n    return min(max(dist.x, dist.y), 0.0) + length(max(dist, 0.0));\n}\n\n// vertical cylinder\nfloat sdRing(vec3 p, float height, float radius, float thickness) {\n    vec2 dist = vec2(abs(abs(length(p.xz)) - radius) - thickness, abs(p.y) - height);\n    return min(max(dist.x, dist.y), 0.0) + length(max(dist, 0.0));\n}\n\nfloat remap(float v, float minOld, float maxOld, float minNew, float maxNew) {\n    return minNew + (v - minOld) * (maxNew - minNew) / (maxOld - minOld);\n}\n                \n// Based upon Unity's shadergraph library functions\nvec3 RotateAboutAxis(vec3 In, vec3 Axis, float Rotation)\n{\n    float s = sin(Rotation);\n    float c = cos(Rotation);\n    float one_minus_c = 1.0 - c;\n    \n    Axis = normalize(Axis);\n    mat4 rot_mat = mat4(   \n        one_minus_c * Axis.x * Axis.x + c, one_minus_c * Axis.x * Axis.y - Axis.z * s, one_minus_c * Axis.z * Axis.x + Axis.y * s, 0.0,\n        one_minus_c * Axis.x * Axis.y + Axis.z * s, one_minus_c * Axis.y * Axis.y + c, one_minus_c * Axis.y * Axis.z - Axis.x * s, 0.0,\n        one_minus_c * Axis.z * Axis.x - Axis.y * s, one_minus_c * Axis.y * Axis.z + Axis.x * s, one_minus_c * Axis.z * Axis.z + c, 0.0,\n        0.0,                                        0.0,                                        0.0,                               1.0\n    );\n    return (rot_mat * vec4(In, 1.0)).xyz;\n}\n \nvec3 LinearToGammaSpace (vec3 linRGB)\n{\n    linRGB = max(linRGB, vec3(0.f, 0.f, 0.f));\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return max(1.055 * pow(linRGB, vec3(0.416666667)) - vec3(0.055), 0.f);\n}\n\nvec3 GammaToLinearSpace (vec3 sRGB)\n{\n    // Approximate version from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n    return sRGB * (sRGB * (sRGB * 0.305306011f + 0.682171111f) + 0.012522878f);\n}\n\nvec3 hdrIntensity(vec3 emissiveColor, float intensity)\n{\n    // apply intensity exposure\n    emissiveColor.xyz *= pow(2.0, intensity);\n    \n    return emissiveColor;\n}\n    \n// Based upon Unity's shadergraph library functions\nvec3 RGBToHSV(vec3 rgb)\n{\n    // Hue: red = 0/6, yellow = 1/6, green = 2/6,\n    //      cyan = 3/6, blue = 4/6, magenta = 5/6\n    vec3 hsv;\n    float cmax = max(rgb.r, max(rgb.g, rgb.b));\n    float cmin = min(rgb.r, min(rgb.g, rgb.b));\n    \n    hsv.z = cmax; // value\n\n    float chroma = cmax - cmin;\n    //if(chroma != 0.0)\n    {\n        hsv.y = chroma / cmax; // saturation\n\n        //if(cmax == rgb.r)\n        if(rgb.r > rgb.g && rgb.r > rgb.b)\n        {\n            hsv.x = (0.0 + (rgb.g - rgb.b) / chroma) / 6.0; // hue\n        }\n        //else if(cmax == rgb.m_Green)\n        else if(rgb.g > rgb.b)\n        {\n            hsv.x = (2.0 + (rgb.b - rgb.r) / chroma) / 6.0; // hue\n        }\n        else\n        {\n            hsv.x = (4.0 + (rgb.r - rgb.g) / chroma) / 6.0; // hue\n        }\n\n        // Make sure hue is in range [0..1]\n        hsv.x = fract(hsv.x);\n    }\n    //else\n    //{\n    //    hsv.x = 0.0; // rnd();\n    //}\n    return hsv;\n}\n    \n// Based upon Unity's shadergraph library functions\nvec3 HSVToRGB(vec3 c){\n	vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n	return c.z * mix(K.xxx, saturate(abs(fract(c.x + K.xyz) * 6.0 - K.w) - K.x), c.y);\n}\n\nvec3 discColor(float r, float radius)\n{\n    vec3 newColor = vec3(1.0, 0.55, 0.0);\n    \n    // Distance intensity fall-off\n    float intensity = remap(r, _innerDiscRadius, _outerDiscRadius, 0.5, -1.2);\n    intensity *= abs(intensity);\n    \n    // Doppler beaming intensity change\n    vec3 rotatePos = RotateAboutAxis(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 0.01);\n    float dopplerDistance = (length(rotatePos - u_camPos) - length(vec3(0.0, 0.0, 0.0) - u_camPos)) / radius;\n    intensity += dopplerDistance * 2.0 * _dopplerEffect;\n        \n    newColor = hdrIntensity(newColor, 1.0 * intensity);\n    \n    // Distance hue shift\n    vec3 hueColor = RGBToHSV(newColor);\n    float hueShift = saturate(remap(r, _innerDiscRadius, _outerDiscRadius, 0.0, 1.0));\n    hueColor.r += hueShift * _hueShift;\n    newColor = HSVToRGB(hueColor);\n    \n    return newColor;\n}\n\n// create a uv mapping for a flat disc\nvec2 diskUV(vec3 p, float outerDiskRadius, float innerDiskRadius) {\n    vec2 p2D = vec2(p.x, p.z);\n    float y = dot(vec2(0, 1), p2D);\n    float x = dot(vec2(1, 0), p2D);\n\n    float phi = 0.5 * (atan(y, x) / 3.1415927) + 0.5;\n    float r = remap(length(p2D), innerDiskRadius, outerDiskRadius, 0.0, 1.0);\n\n    phi = mod(phi - 0.2 * u_time, 1.0);\n    //r = mod(r + 0.01 * u_time, 1.0);\n\n    //seam when y flips pos to neg\n\n    //bandaging the seam creates more seams\n    //if(abs(y) < 0.01) phi = 1.0;\n\n    return vec2(r, phi);\n}\n\n//minimum of distances to all objects in scene\nfloat scene(vec3 p) {\n  //float plane = p.y + 1.0;\n  float sphere = sdSphere(p, _sphereRadius); //0.17\n  float disk = sdRing(p, 0.001, (_outerDiscRadius + _innerDiscRadius) / 2.0, (_outerDiscRadius - _innerDiscRadius) / 2.0);\n\n  float distance = min(sphere, disk);\n  return distance;\n}\n\n//ray origin ro, ray direction rd\nfloat raymarch(vec3 ro, vec3 rd) {\n  float dO = 0.0;\n  float dS = 0.0;\n  vec3 p = ro;\n  vec3 color = vec3(0.0);\n\n  for(int i = 0; i < MAX_STEPS; i++) {\n    p += rd * dS;\n    dS = scene(p);\n\n    dO += dS;\n    \n    vec3 dirToCentre = normalize(-1.0 * p);\n    float dstToCentre = length(p);\n    float force = _lightBending / (dstToCentre*dstToCentre);\n    rd = normalize(rd + dirToCentre * force * dS);\n\n    if(dO > MAX_DIST || dS < SURFACE_DIST) {\n        break;\n    }\n  }\n  return dO;\n}\n\nvoid main() {\n  //centered screen space uv\n  vec2 uv = gl_FragCoord.xy/u_resolution.xy;\n  uv -= 0.5;\n  uv.x *= u_resolution.x / u_resolution.y;\n  //uv.y *= u_resolution.y / u_resolution.x;\n\n  //uv issue was solved (u_res is the whole website window, not just the canvas)\n  //panning issue still not solved, postponed for now\n\n  // Ray Origin - camera\n  vec3 ro = u_camPos;\n\n  // Ray Direction\n  vec3 rd = (vec4(normalize(vec3(0.24 *uv, -1.0)), 1.0) * u_camRot).xyz;\n  // Raymarching\n  float d = raymarch(ro, rd);\n  vec3 p = ro + rd * d;\n\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\n  if(d<MAX_DIST) {\n    if(length(p) < _sphereRadius + _voidCutoff) {\n      color = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else {\n      vec2 dUV = diskUV(p, _outerDiscRadius + 0.01, _innerDiscRadius - 0.1);\n      float distPercent = 1.0 - dUV.x;\n      float noise = texelFetch(u_noiseTex, ivec2(vec2(mod(dUV.x + 0.01 * u_time, 1.0), dUV.y) * vec2(256.0, 256.0)), 0).r;\n      float blowOut = 5.0 * pow(noise, 5.0)*distPercent*distPercent*distPercent;\n\n      color = vec4(discColor(dUV.x, 1.0) + blowOut, noise * min(2.0*distPercent, 1.0));\n    }\n  }\n\n  gl_FragColor = color;\n}\n",vertexShader:"\n//varying vec3 Normal;\n//varying vec3 Position;\nvarying vec2 vUv;\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec3 u_camPos;\nuniform mat4 u_camRot;\n\nvoid main() {\n  //Normal = normalize(normalMatrix * normal);\n  //Position = position;\n\n  vUv = uv;\n\n  vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectedPosition = projectionMatrix * viewPosition;\n\n  gl_Position = projectedPosition;\n}\n",transparent:!0,side:a.DoubleSide}),n.children]})}function f(n){let e=(0,s.useRef)(null);return(0,r.x)(()=>{let o=e.current;o&&(o.rotation.y+=.1*n.spinSpeed)}),(0,i.jsx)("mesh",{ref:e,...n,children:n.children})}var d=o(6179);function m(n){let e=(0,s.useRef)(null),o=(0,r.w)(n=>n.camera);return(0,r.x)(()=>{let n=e.current;n&&n.setRotationFromEuler(o.rotation)}),(0,i.jsxs)("mesh",{ref:e,...n,renderOrder:0,children:[(0,i.jsx)(d.x,{scale:[5,5,5],position:[0,2,0],color:"white",anchorX:"center",anchorY:"middle",children:n.text}),(0,i.jsx)("meshStandardMaterial",{transparent:!0})]})}var x=o(4410),g=o(6547);function p(n){let e=(0,s.useRef)(null),[o,t]=(0,s.useState)(!1),[c,l]=(0,s.useState)(.2);(0,r.x)((i,t)=>{let r=e.current;if(!r)return;let{clock:s}=i;r.rotation.y+=.1*n.spinSpeed*t,l(a.MathUtils.lerp(c,o?.8:.2,.02))}),(0,s.useEffect)(()=>{if(o){var i;let o=new a.Vector3;null===(i=e.current)||void 0===i||i.getWorldPosition(o),n.setTooltipPos({x:o.x,y:o.y,z:o.z})}},[o,n]);let[v]=(0,u.m)(["Textures/Donjon/donjon.png"]);return(0,i.jsxs)("mesh",{ref:e,...n,onClick:e=>window.location.href=n.href,onPointerOver:()=>{t(!0),document.body.style.cursor="pointer",n.tooltip&&n.setTooltipName(n.tooltip)},onPointerOut:()=>{t(!1),document.body.style.cursor="auto",n.setTooltipName("")},children:[(0,i.jsx)("sphereBufferGeometry",{args:[1,288,288]}),(0,i.jsx)("meshMatcapMaterial",{map:v,displacementMap:v,displacementScale:c,flatShading:!0}),n.children]})}function y(){let[n,e]=(0,s.useState)({x:0,y:0,z:0}),[o,t]=(0,s.useState)(""),r=(0,i.jsx)(v,{scale:new a.Vector3(1.5,1.5,1.5)}),u=(0,i.jsx)(c,{scale:new a.Vector3(.3,.3,.3),href:"/about",spinSpeed:.01,colorBase:new a.Color("#1B7F99"),colorBeach:new a.Color("#7CC65A"),colorMid:new a.Color("#566A41"),colorPeak:new a.Color("#434C2E"),setTooltipPos:e,setTooltipName:t,tooltip:"About"}),d=(0,i.jsx)(c,{scale:new a.Vector3(.1,.1,.1),href:"/",spinSpeed:.1,colorBase:new a.Color("#4C6085"),colorBeach:new a.Color("#39A0ED"),colorMid:new a.Color("#36F1CD"),colorPeak:new a.Color("#13C4A3"),setTooltipPos:e,setTooltipName:t}),x=(0,i.jsx)(c,{scale:new a.Vector3(.1,.1,.1),href:"/gallery",spinSpeed:.5,colorBase:new a.Color("#666370"),colorBeach:new a.Color("#9B7874"),colorMid:new a.Color("#D33E43"),colorPeak:new a.Color("#FF220C"),setTooltipPos:e,setTooltipName:t,tooltip:"Gallery"}),g=(0,i.jsx)(l,{scale:new a.Vector3(.5,.5,.5),href:"/",spinSpeed:.5,colorBase:new a.Color("#C5E6A6"),colorBeach:new a.Color("#BDD2A6"),colorMid:new a.Color("#B9BEA5"),colorPeak:new a.Color("#A7AAA4"),setTooltipPos:e,setTooltipName:t}),y=(0,i.jsx)(p,{scale:new a.Vector3(.25,.25,.25),href:"/experiments",spinSpeed:-.35,setTooltipPos:e,setTooltipName:t,tooltip:"Experiments"}),h=(0,i.jsx)(c,{scale:new a.Vector3(.15,.15,.15),href:"https://mattercollapse.itch.io/",spinSpeed:-1.5,colorBase:new a.Color("#F6AE2D"),colorBeach:new a.Color("#55DDE0"),colorMid:new a.Color("#33658A"),colorPeak:new a.Color("#2F4858"),setTooltipPos:e,setTooltipName:t,tooltip:"Itch.io"});return(0,i.jsxs)(f,{position:new a.Vector3(0,0,0),spinSpeed:0,children:[(0,i.jsx)(f,{position:new a.Vector3(0,0,0),spinSpeed:.01,children:r}),(0,i.jsxs)(f,{position:new a.Vector3(0,0,0),spinSpeed:-.01,children:[(0,i.jsxs)(f,{position:new a.Vector3(6,0,0),spinSpeed:-.02,children:[u,(0,i.jsx)("mesh",{"rotation-x":.5*Math.PI,children:(0,i.jsx)("torusBufferGeometry",{args:[1,.002,4,128]})}),(0,i.jsx)("mesh",{"rotation-x":.5*Math.PI,children:(0,i.jsx)("torusBufferGeometry",{args:[1.5,.002,4,128]})})]}),(0,i.jsx)(f,{position:new a.Vector3(6,0,0),spinSpeed:-.007,children:(0,i.jsx)(f,{position:new a.Vector3(1,0,0),spinSpeed:.01,children:d})}),(0,i.jsx)(f,{position:new a.Vector3(6,0,0),spinSpeed:.009,children:(0,i.jsx)(f,{position:new a.Vector3(-1.5,0,0),spinSpeed:.015,children:x})})]}),(0,i.jsx)(f,{position:new a.Vector3(0,0,0),spinSpeed:.005,children:(0,i.jsx)(f,{position:new a.Vector3(9,0,0),spinSpeed:.05,children:g})}),(0,i.jsx)(f,{position:new a.Vector3(0,0,0),spinSpeed:-.002,children:(0,i.jsx)(f,{position:new a.Vector3(11,0,0),spinSpeed:-.001,children:y})}),(0,i.jsx)(f,{position:new a.Vector3(0,0,0),spinSpeed:-.001,children:(0,i.jsx)(f,{position:new a.Vector3(12,0,0),spinSpeed:.01,children:h})}),(0,i.jsx)("mesh",{"rotation-x":.5*Math.PI,children:(0,i.jsx)("torusBufferGeometry",{args:[6,.002,4,128]})}),(0,i.jsx)("mesh",{"rotation-x":.5*Math.PI,children:(0,i.jsx)("torusBufferGeometry",{args:[9,.002,4,128]})}),(0,i.jsx)("mesh",{"rotation-x":.5*Math.PI,children:(0,i.jsx)("torusBufferGeometry",{args:[11,.002,4,128]})}),(0,i.jsx)("mesh",{"rotation-x":.5*Math.PI,children:(0,i.jsx)("torusBufferGeometry",{args:[12,.002,4,128]})}),(0,i.jsx)(m,{position:new a.Vector3(n.x,n.y,n.z),text:o})]})}function h(){return(0,i.jsx)("main",{className:"flex h-full flex-col items-center",children:(0,i.jsxs)(t.Xz,{camera:{near:.1,far:1e3,zoom:1,position:[0,15,10],fov:60},dpr:1,children:[(0,i.jsx)(x.qA,{files:"Textures/Environment/My Space Skybox.hdr",background:!0}),(0,i.jsx)("ambientLight",{args:[16777215],intensity:.1}),(0,i.jsx)("pointLight",{position:[0,0,0],intensity:1,color:"orange"}),(0,i.jsx)(y,{}),(0,i.jsx)(g.z,{enablePan:!1})]})})}}},function(n){n.O(0,[433,689,16,700,971,23,744],function(){return n(n.s=9306)}),_N_E=n.O()}]);